'''
Created on 21 03 2022

@author: ManuLahariya
'''
import sys
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt


def airflow_tower(fanpowers, fandiams, celldimensions, Kel, eta_motor, eta_fan, rho_air):
    """Calculate the airflow generated by all fans of a cooling tower combined in kg/s,
    based on the supplied power to the fan motors.
    Calculation is done on air of 15 degrees C.
    Kel: eliminator coefficient (if unknown, set to 1)
    eta_motor: electric power to shaft power efficiency of motor (if unknown, set to 0.95)
    eta_fan: shaft power to wind power efficiency of fan (if unknown, set to 0.55)
    rho_air: density of the air in kg/qubic meter
    """
    totalair = 0
    counter = 0
    for fanpower in fanpowers:
        m_air = (((2 * fanpower * 1000 * rho_air * (
                    celldimensions[0] * celldimensions[1]) ** 2 * eta_fan * eta_motor) / (6.5 + Kel + 2 * (
                    (celldimensions[0] * celldimensions[1]) / ((fandiams[counter] / 2) ** 2 * math.pi)) ** 2)) ** (
                             1 / 3))
        totalair = totalair + m_air  # the total amount of air, from all the fans, in kg/s
        counter = counter + 1
        # if no fans are active, still some cooling is present due to natural air draft.
        if totalair == 0:
            totalair = (((2 * 110 * 1000 * rho_air * (
                        celldimensions[0] * celldimensions[1]) ** 2 * eta_fan * eta_motor) / (6.5 + Kel + 2 * (
                        (celldimensions[0] * celldimensions[1]) / ((fandiams[counter] / 2) ** 2 * math.pi)) ** 2)) ** (
                                    1 / 3)) * 0.5
    return totalair



def calc_rho_air(T_air, rel_hum, p_atm):
    if T_air < 0:
        sat_pres = 0.61115 * math.exp(
            (23.036 - (T_air / 333.7)) * (T_air / (279.82 + T_air))) * 1000  # Buck 1996 equation, in Pa, for T < 0
    else:
        sat_pres = 0.61121 * math.exp(
            (18.678 - (T_air / 234.5)) * (T_air / (257.14 + T_air))) * 1000  # Buck 1996 equation, in Pa, for T > 0

    T_air = T_air + 273.15

    P1 = sat_pres
    Pv = (P1 * (rel_hum / 100))
    Pd = p_atm - Pv
    rho_air = (((Pd) / (287.058 * T_air)) + ((Pv) / (461.495 * T_air)))
    return rho_air


def calc_wetbulb_temp(T_air, rel_hum):
    Twetbulb = T_air * np.arctan(0.151977 * (rel_hum + 8.313659) ** (1 / 2)) + np.arctan(T_air + rel_hum) - np.arctan(
        rel_hum - 1.676331) + 0.00391838 * (rel_hum ** (3 / 2)) * np.arctan(0.023101 * rel_hum) - 4.686035
    return Twetbulb


def cooling_tower_data(filename, step):
    # COOLING TOWER DATA READ IN
    df_coolingtower = pd.read_excel(filename)
    if step == "quarters":
        df_coolingtower["DATETIME"] = df_coolingtower["DATETIME"].dt.round('15min')
    if step == "minutes":
        df_coolingtower["DATETIME"] = df_coolingtower["DATETIME"].dt.round('1min')
    df_coolingtower = df_coolingtower.set_index("DATETIME")
    return df_coolingtower


def calc_enthalpy_moist_air(T_air, rel_hum, p_atm):
    if T_air < 0:
        sat_pres = 0.61115 * math.exp(
            (23.036 - (T_air / 333.7)) * (T_air / (279.82 + T_air))) * 1000  # Buck 1996 equation, in Pa, for T < 0
    else:
        sat_pres = 0.61121 * math.exp(
            (18.678 - (T_air / 234.5)) * (T_air / (257.14 + T_air))) * 1000  # Buck 1996 equation, in Pa, for T > 0

    w = 0.622 * (((rel_hum / 100) * sat_pres) / (p_atm - ((rel_hum / 100) * sat_pres)))  # in kg_humidity/kg_dry_air
    if T_air == 0:
        density = (p_atm - 0.387 * rel_hum / 100 * sat_pres) / (287 * (T_air + 0.0001))
    else:
        density = (p_atm - 0.387 * rel_hum / 100 * sat_pres) / (287 * T_air)  # in kg_moist_air/m³
    # cpa = 1.005+(1.35*(10**(-8))*((T_air + 30)**2)) #in kJ/kg.K
    # cpv = 1.8684 + 0.0095*(T_air/100) + 0.00373*((T_air/100)**2) # in kJ/kg.K
    # cp = cpa + w*cpv # in kJ/kg_dry_air.K
    enthalpy = 1.006 * T_air + w * (2500 + 1.863 * T_air)  # in kJ/kg_dry_air
    return enthalpy


# %%
def T_basin_calculation(T_basin_initial,Q, P_Fan1, P_Fan2, weathermask):
    # calculate the number of quarters during the windowed time period, as this is the timestep for simulation
    steps = weathermask.shape[0]
    Power_df = pd.DataFrame({'Power Fan 1': np.repeat(P_Fan1,steps),
                             'Power Fan 2': np.repeat(P_Fan2,steps)})

    Q_process = np.repeat(Q, steps)

    # for timestep 0, set the basin temperature to the measured basin temperature
    T_bassin = T_basin_initial

    # define constants
    Cw = 4.186  # [kJ/kg.K]
    rho_water = 997  # [kg/m³]

    # define process specific parameters.
    m_bassin = 900  # total volume of water in the cooling system, in m³
    Trange = 8  # difference in temperature between hot water inlet and water exit (or Tbasin)
    Tmin = 5  # min temperature of the leaving cooling water (= temperature basin)
    Tmax = 30  # max temperature of the leaving cooling water (= temperature basin)
    T_setpoint = 17  # setting the setpointtemperature of the cooling water as start temperature of the basin
    rel_hum_air_out = 100  # relative humidity of outgoing air at the cooling tower, in percentage
    fandiams = [6.2, 6.2]  # an array with the fan diameters-
    celldimensions = [11, 12]  # the cell dimensions [length in meters, width in meters]


    results = [T_basin_initial]
    steps = int(steps)
    for p in range(0, steps):
        # clear_output(wait=True)
        # print("step " + str(p+1) + " of " + str(steps))

        rel_hum_air_in = weathermask["hum"][p]
        P_atm = (weathermask["pres"][p]) * 100
        T_air_in = weathermask["temp"][p]
        rho_air = calc_rho_air(T_air_in, rel_hum_air_in, P_atm)
        Qprocess = Q_process[p]
        # change Qp not randomly
        # we have a nominal value
        # increase to 2Qp
        # change randomly between Q, 4/3Q, 5/3Q, 2Q

        T_air_out = T_bassin + Trange
        Twetbulb = calc_wetbulb_temp(T_air_in, rel_hum_air_in)
        Tapproach = T_bassin - Twetbulb

        # define the total airflow through the tower
        m_air = airflow_tower(Power_df.iloc[p,:].values, fandiams, celldimensions, 1, 0.95, 0.55, rho_air)
        # define the cooling capacity of the cooling tower
        Qtower = (m_air * (calc_enthalpy_moist_air(T_air_out, rel_hum_air_out, P_atm) - calc_enthalpy_moist_air(T_air_in,
                                                                                                                rel_hum_air_in,
                                                                                                                P_atm)))
        # define the delta T
        i = 1
        # execute while loop 15x, because quarter = 15 minutes = simulation timestep
        x = 16
        while (i < x):
            Qtower = (m_air * (
                        calc_enthalpy_moist_air(T_air_out, rel_hum_air_out, P_atm) - calc_enthalpy_moist_air(T_air_in,
                                                                                                             rel_hum_air_in,
                                                                                                             P_atm)))
            dT_bassin = (Qprocess * 1000 - Qtower) / (Cw * m_bassin * rho_water) * 60  # multiplied by 60: second to minute
            T_bassin = T_bassin + dT_bassin  # the calculated bassin temperature, at t+1 (timesteps of 1 minute are being used)
            results.append(T_bassin)
            Tapproach = T_bassin - Twetbulb
            T_air_out = T_bassin + Trange
            i = i + 1
            # define the new basin temperature
        # T_bassin = T_bassin + dT_bassin  # the calculated bassin temperature, at t+1 (timesteps of 1 minute are being used)

        # results.append(T_bassin)

    results.pop(0)
    return np.array( results )

